---
title: K8S_개념정리
tags:
  - kubernetes
  - K-PaaS
date: 2024_04_22
Modify_Date: 
reference:
---
# K8S_개념정리

![[쿠버네티스.jpeg]]


### 쿠버네티스를 이해하기전 서버시장의 상황..

수 년 전만 하더라도 대부분의 소프트웨어 어플리케이션은 하나의 프로세스 또는 몇 개의 서버에 분산되어 프로세스로 실행되는 거대한 모놀리스(Monolithic) 형태가 주를 이루었습니다. 이러한 레거시 시스템은 여전히 많이 펴져 있습니다. 엔지니어들은 장애가 발생하면 이를 수리하거나 정상적인 서버로 migration 등의 작업을 진행했었죠. 작업은 장애 원인과 인프라의 복잡도에 따라 오래 걸리거나 어려운 경우가 많았습니다.

그래서 모놀리스 레거시 시스템은 점차 사용자 및 운영자 관점에서 상황에따라서 편한 클라우드화 되며 선발대 기업들은 IaaS, PaaS, SaaS 등으로 클라우드 서비스를 세분화 했습니다.
오늘은 PaaS 시장의 주요 기술인 Kubernetes(이하 K8s)에 대해서 이야기하려 합니다.

## 1. 쿠버네티스와 컨테이너 런타임 엔진

쿠버네티스를 이해하기 전에 컨테이너를 먼저 이해하여야 합니다. 컨테이너는 OS, 어플리케이션 등의 파일을 하나의 런타임 환경으로 묶는 기술입니다. 생성된 컨테이너는 호스트 운영 체제의 커널을 공유하며 어플리케이션을 위한 격리된 환경을 제공합니다. 이를 이용하여 개발자는 자신의 어플리케이션을 구동하기 위하여 실행 환경, 의존성 등을 패키징(Container images)하고 이 이미지를 실행하여 격리된 **프로세스**로 실행합니다. 다시 말해서 컨테이너란 이미지화 되어있는 어플리케이션 프로세스를 격리하는 기술입니다. 이를 위해 필요한것이 **컨테이너 런타임 엔진** 이고 런타임 엔진에 대표적으로 Docker engin, CRI-O, conatinerd 등이 있습니다. 
컨테이너 기술을 이용하면 컴퓨팅 리소스를 가상화 방식보다 더 작게 나눌 수 있습니다. 추상화된 리소스를 할당하는것이 아닌, 표면상으로는 OS 에서 작동하는 프로세스기 때문이죠. 
![[Pasted image 20240426111808.png]]
_출처 : https://www.redhat.com/ko/topics/containers/whats-a-linux-container

운영자 입장에서는 이렇게 잘게 나눈 컨테이너를 효과적으로 관리하기 위한 새로운 가이드라인이 필요했습니다.
```bash
podman run -it --name ubuntu-dev ubuntu:latest
podman delete ubuntu-dev
podman exec ubuntu-dev /bin/bash ls
```
매번 이런 명령어를 치면서 인프라를 관리 할 수 없으니까요.

따라서 많은 Orchestration(구성, 조율, 관리)하기 위한 프로그램이 많이 나왔습니다. 새로운 시장이니 만큼 역사를 찾아보면 치열했지만, 그중에서 컨테이너 시장의 ***de facto(사실상, 공식, 표준)*** 가 된 Kubernetes(K8s, 쿠버네티스)를 소개합니다.

---
### 1.1 Kubernetes 란?
#### 1.1.1 Kubernetes의 역사
오랜 시간 동안 구글은 보그(Borg 이후 Omega로 바뀐 시스템)라는 내부 시스템을 개발해 개발자와 관리자가 수천 개의 서비스를 관리하는데 사용했습니다. 개발자와 관리자를 위한 시스템인 만큼 개발과 관리의 단순화, 인프라 활용률을 중요시하게 생각했죠. 구글은 10년간 보그와 오메가를 비밀로 유지하다가 2014년에 그동안의 노하우를 기반으로 하는 쿠버네티스를 출시 했습니다.

#### 1.1.2 쿠버네티스의 핵심 역할

**개발자의 편의성**
개발자가 인프라s 서비스를 구현하지 않아도 됩니다. 관리자가 사전에 만들어둔 정책으로 리소스 분배, 스케일링, 복구, 다중화, 네트워크 등을 쿠버네티스는 자동적으로 수행합니다. 따라서 개발자는 어플리케이션의 실제 기능을 구현하는데 온전히 집중할 수 있죠.

**관리자의 리소스 컨트롤**
관리자는 쿠버네티스로 구성한 클러스터 어디에서 어플리케이션이 실행되고 있는지 고민하지 않아도 됩니다. 쿠버네티스는 노드 상황을 자동적으로 파악해 어플리케이션의 재배치등이나 장애복구를 진행하기 때문입니다. 리소스의 수동 스케줄링보다 더 빠르고 정확하죠.

### 2.1 쿠버네티스 클러스터의 구성

쿠버네티스 클러스터는